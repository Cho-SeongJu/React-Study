##################################
# state

상태 값을 변경할 수 있고 변경되면 컴포넌트가 랜더링이 될 수 있게 한다.

const [state, setState] = useState(// 초기값);
state : 관리하고 있는 값
setState : 관리하고 있는 값을 변경할 때 쓰는 함수

함수 컴포넌트는 그저 함수이다.

함수 컴포넌트에서 내부적으로 상태를 관리해야 하는일이 필요하다.

import React, { useState } from "react";
const [state, setState] = useState()

setState()는 컴포넌트의 re-rendering을 발생시킨다.

## state 불변성(immutable)
불변성이란 변하지 않는 성질
프로그래밍에서 불변성을 지킨다 -> 메모리 영역의 값을 직접적으로 변경하지 않는다.

setState() -> 컴포넌트 re-rendering을 하는데
setState를 한다고 해서 무조건 일어나지 않는다.
실행하기 전 상태와 실행할 때 넣은 값과 다른지 먼저 비교를 하고 다르면 실행을 한다.

불변성을 지키지 않고, 메모리 영역의 값을 직접 변경하면 리액트는 state가 바뀌었다고 인지하지 못한다.
왜냐하면 리액트는 이전 state과 이후 state를 비교할 때 얕은 비교를 하기 때문이다.

참조타입 -> 불변성을 가지고 있지 않다.
변수에 참조 타입의 값을 할당하면, 메모리 값이 담긴 주소가 저장된다.


### 원시 타입(Referenc type) state 다루어보기 - boolean, number, string

+1 버튼 : 클릭하면 Counter 값을 1 증가
show and hide 버튼 : 클릭하면 Counter를 나타나거나 사라지게 한다.
change Operator : +, -, * 중 하나를 랜덤하게 선택하여 Counter 계산에 적용한다.

### 참조 타입(Referenc type) state 다루어보기 
const [count, setCount] = useState(0);
const [show, setShow] = useState(true);
const operators = ["+", "-", "*"];

이 구조를 참조타입으로 하나로 합치면
const [info, setInfo] = useState({
    count : 0,
    show: true,
    operator: operators[0],
});
이렇게 가능하다.

이렇게 하고 이제 setInfo({...info, operator : ~})
이렇게 해서 원래 info의 값고 새로운 operator를 비교해서 다르면 리랜더링한다.

객체는 참조타입이기 때문에 만약 새로운 변수에 객체를 복사하면 이건 얕은 복사이기 떄문에
똑같은 메모리 주소를 가르키고 값을 변경한다고 하면 리엑트에서 이 값들이 변경한 것을 탐지를 못하기 떄문에
꼭 스프레드 문법으로 스프레드 객체와 값을 넘겨줘야 한다.

Array도 가능하다
import React, {useState} from "react";
const [array, setArray] = useState("a","b", "c","d");

<잘못된 사용법>
array[0] = "e"
const newArray = array
ex) setArray(newArray)

<올바른 사용법>
ex) setArray([...array, newItem])
ex) setArray(array.filter(arr => {}))
